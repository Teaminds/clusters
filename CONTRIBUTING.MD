## Принципы разработки для данного проекта:
- каждый экземпляр нестандартного класса (объект) должен иметь атрибут `uid` полученый через `core.utils().uid()` и регистрироваться в `core.registry().register(self)` при инициализации 
- обращение к атрибутам в объекте допускается только внутри методов этого же объекта, обращение извне только к методам объекта.
- допускается как передача объектов целиком, так и передача `uid` объектов с последующим получением объекта через `core.registry().get(uid)`. Рекомендуется если связь длительная и четко иерархическая хранить в родителя дочерний объект, а в дочернем объекте хранить `uid` родителя (и то только при необходимости для логики). А в ситуациях когда связь "разовая", "редкая", то возможно проще использовать именно `uid` и получать объект по мере необходимости.
- при получении объекта по `uid` из реестра, необходимо подсвечивать ожидаемый тип объекта `core.registry().get(uid): Component`, но проверять его необязательно - предполагается что автор сам будет следить за типами объектов
- если метод выызвается только внутри объекта - он может быть приватным (начинаться с _ )
- если метод вызывается только внутри объекта и только внутри одного метода и только один раз - он может быть не отдельным методом, а частью логики этого метода
- сигналы это инструмент информирования, а не передачи команд. Его рекомендуется использовать для уведомления других объектов, а не для явного вызова методов других объектов. То есть например `unit_moved` без параметров и `specific_unit_moved` с `uid` юнита которые сообщают о том что юнит сдвинулся всем кому это вообще интересно, это ОК, а вот сигнал `increse_income` с параметром `uid` юнита который заставляет другой объект увеличить доход юнита - это не ОК, тут лучше просто вызвать метод объекта напрямую если это необходимо.
- при изменении состояния объекта, которое может быть интересно другим объектам рекомендуется использовать систему сигналов для уведомления об этом изменении
- при подаче сигналов это нормально подавать несколько сигналов потряд, например `unit_moved` без параметров и `specific_unit_moved` с `uid` юнита в качестве аргумента
- объект важный для логики в разных местах можно хранить в `core.shortcuts()` под соотвтетсвующими ключами, например `current_level` для упрощения поиска этих объектов и работы с ними. Важно не злоупотреблять этим и не хранить там всё подряд

## Объект `core`
Если импортировать из `system_components.Core_Builded` переменную `core`, то в ней будут находится основные не связанные с игровыми механиками системы, которые можно вызвать как методы:
- `utils()` - набор полезных утилит
- `signals()` - система позволяющая отправлять "сигналы" и "подписываться" на них. При подписке указывается конкретный объект и метод которые будут вызваться системой при отправке "сигнала" (аргументы пробрасываются)
- `registry()` - реестр объектов игры. Объекты регистрируются в два индекса - по атрибуту `uid` и по атрибуту `system_name` - и то и другое должно быть уникальным. `uid` - обязателен, а `system_name` опционален (но может содержать осмысленную строку, а не просто uid). Объекты можно не только регистрировать но и получать по `uid` или `system_name`
- `log_system()` - логгер
- `shortcuts()` - система позволяющая сохранять объекты под строковыми ярлыками.
  - один из `shortcuts` на данный момент это `core.shortcuts().get('current_level')` - который является ссылкой на уровень который сейчас открыт. Это может быть полезно когда нужно вызвать что-то связанное с текущим уровнем из глубины логики. Это не самый изящный способ, но может быть полезно.